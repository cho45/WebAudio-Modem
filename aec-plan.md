# WebAudio DSSS+DPSK PoC 実装ステップ

## フェーズ1: オフライン信号処理PoC（段階的ステップと検証内容）
1. DPSK変調・復調のみ（DSSSなし）でbit誤り率・動作確認
   - パラメータ: **搬送波10kHz**, **サンプリングレート48kHz**（WebAudio標準）, **シンボルレート自動計算**
   - まずは「ビット列→DPSK変調→サンプル列」を生成し、同期がとれている（シンボル境界が既知）前提で復調し、bit誤り率0となることを確認する。DPSKアルゴリズム自体の正しさを検証。
2. DSSS拡散・逆拡散を追加し、DSSS+DPSKでのbit誤り率・同期性能を評価
   - パラメータ: **M系列拡散率31**（生成多項式x⁵+x³+1, シード任意非0）, **1チップあたりのサンプル数自動計算**
   - DSSSの自己相関特性を利用した系列同期（コード同期）を実装。変調済みサンプルの先頭を意図的にオフセットしても、同期点を自動検出し正しく復調できるかを検証。DSSSの同期性能・頑健性を評価。
   - プリアンブル: **PN系列の一部をそのまま使用**
   - 同期検出: **スライディング相関法**、ウィンドウ長=拡散率、**相関ピーク比2.0以上で同期成立**、**相関ステップ幅=1サンプル**
   - 再同期: **1000シンボルごとに再探索**
3. soft value（信頼度値）出力・可視化対応
   - 復調時にsoft value（信頼度値, **LLRスケーリング int8_t -128～+127**）を出力し、ヒストグラムや散布図などで可視化。soft-decision FECへの入力値としての有用性も検証。
4. データフレーム解析（SOH/長さの検出・抽出、soft value活用）
   - フレーム構造: 下記「データフレーム構造（ASCIIアート）」参照
   - 復調soft value列から、データフレーム層でSOH/長さを検出・抽出し、データ本体部分を切り出す。
   - SOHや長さ等FEC非保護フィールドのsoft valueも活用し、信頼度が低い場合はフレーム破棄・再同期等の処理を行う。
5. FEC（LDPC）を追加し、誤り訂正前後の性能比較
   - パラメータ: **LDPC n=128, rate=1/2, H行列固定, 反復10回, soft値int8_t**
   - データ本体部分のみをFEC復号にかけ、FECなし・ありでbit誤り率や復元率がどれだけ改善されるかを比較評価。
6. テストデータをDSSS+DPSK変調し、AudioBufferやWAVファイルに出力
   - 生成した信号をファイル出力し、外部ツール等で波形やスペクトルも確認。
7. 変調信号を復調・逆拡散し、元データと一致するか確認
   - 端末間や異なる環境での再現性・互換性も含めて最終検証。

## フェーズ2: WebAudioリアルタイムPoC
1. AudioContextで信号を再生する送信処理の実装
   - **サンプリングレート48kHz, AudioWorkletバッファ128サンプル**
   - ブラウザ上でリアルタイムにDSSS+DPSK信号を生成・再生できるかを検証。
2. マイク入力を録音し、バッファに格納する受信処理の実装
   - マイク経由で受信した信号をバッファ化し、オフラインと同等の復調・逆拡散ができるかを検証。
3. 録音データにDPSK復調＋DSSS逆拡散を適用
   - 実環境ノイズ・歪み下での復調性能・同期性能を評価。
4. soft valueをFEC（LDPC）に渡し、誤り訂正の有無を確認
   - FECの有無でリアルタイム伝送の誤り耐性がどれだけ向上するかを評価。

## フェーズ3: 統合・UI・評価
1. 送信・受信UI、パラメータ調整UIの作成
   - ユーザーが各種パラメータを調整しながら伝送実験できるUIを実装。
2. BER/SNR等の簡易評価指標の表示
   - 伝送品質をリアルタイムで可視化し、各種パラメータの影響を評価。
3. ノイズ・歪み耐性の実験・記録
   - 様々な環境・条件下での伝送性能を記録・比較し、システムの実用性・限界を検証。

- まずはオフラインでbit誤り率や復元率を確認し、次にWebAudio経由での信号劣化・復調性能を評価する。
- 既存のDPSK/FSKデモやWebAudio録音・再生サンプルを流用すると効率的。
- DPSKを使うことで搬送波同期が不要になり、PoC実装が容易になる。

---

## 実装前に決定すべき具体的な項目（利用フェーズ・必要順）
- **DPSK変調パラメータ**（フェーズ1-2）
  - 搬送波周波数:
    - **PC/スマホ標準（20Hz～20kHz）**: 8kHz～12kHz推奨（例: 10kHz）
    - **ノートPC内蔵マイク/スピーカー**: 3kHz～7kHz推奨（例: 5kHz）
    - **電話回線/VoIP（300Hz～3.4kHz）**: 1kHz～2kHz推奨（例: 1.5kHz）
    - ※帯域端は減衰・歪みが大きいため、中心付近を選ぶ
  - サンプリングレート（WebAudioのサンプリングレートと**必ず一致させる**）
  - シンボルレート（サンプルレート÷1シンボルあたりのサンプル数で自動的に決まる）
- **PN系列の種類・パラメータ**（フェーズ1-2）
  - M系列 or Gold系列 or Walsh系列 → M系列
  - シード値・生成多項式・系列長（拡散率
- **DSSSパラメータ**（フェーズ1-2）
  - 拡散率（系列長）
  - 1チップあたりのサンプル数（サンプルレート・シンボルレート・拡散率から自動的に決まる：
    1チップあたりのサンプル数 = サンプルレート ÷ (シンボルレート × 拡散率)
    または 1シンボルあたりのサンプル数 ÷ 拡散率）
- **プリアンブル設計**（フェーズ1-2）
  - PN系列の一部をそのまま使う（系列同期・コード同期のため、DPSK+DSSS段階から必要）
- **同期検出アルゴリズム**（フェーズ1-2）
  - スライディング相関法（自己相関法）を採用
    - 相関ウィンドウ長（通常はプリアンブル長＝拡散率）
    - 相関しきい値（ピーク比（最大値/平均値や2番目ピーク）による判定が現実的）
    - 探索範囲・ステップ幅（何サンプル単位で相関をスライドさせるか）
      - **ステップ幅（相関のスライド間隔）は「1サンプル」または「1/2チップ幅以下」が推奨**
        - 1チップあたりのサンプル数が十分大きい場合は「1サンプル」ごとに相関を計算することで、ピーク検出の精度が最大化される。
        - 計算量削減のため「1/2チップ幅」ごと（例: 1チップ=8サンプルなら4サンプルごと）でも、ピーク検出の精度は大きく損なわれない。
        - **「1チップ幅」ごと（=チップ単位）だと、ピークを見逃すリスクが高まる**ため、最低でも「1/2チップ幅」ごとが推奨される。
        - 相関ピークはチップ境界に必ずしも一致せず、サンプリングのズレや信号歪みでピーク位置がサンプル単位で前後するため、粗いステップだと最大値を検出できない場合がある。
      - **実装例**: 1チップ=8サンプルなら、4サンプルごと（1/2チップ幅）または1サンプルごとに相関を計算する。
      - **計算量と精度のトレードオフ**: ステップ幅を小さくするほど計算量は増えるが、同期精度・ピーク検出精度が向上する。
    - 再同期戦略（同期ロス時の再探索方法）
      - 音声帯域・WebAudio等の端末間通信では、送信側・受信側のサンプリングクロックの微小なズレ（クロックドリフト）により、数秒以上の伝送でチップ境界がサンプル単位で徐々にずれていく現象が現実的に発生する。そのため、長時間伝送や端末間通信では「再同期戦略」は必須設計項目となる。
      - 具体的な再同期戦略例：
        - **一定区間ごと（例: Nシンボルごと）に再度プリアンブル探索を行い、同期点を補正する**
          - （補足）これは「受信データ列の中で、サンプル位置（チップ境界）がクロックドリフト等でずれていないかを、プリアンブルとの相関ピークで再検出し、ピーク位置に合わせてサンプルの区切り（チップ/シンボルの開始点）を補正する」ための処理です。
          - Nの目安：サンプリングレート48kHz・シンボルレート1kHz・クロックドリフト50ppmの場合、1チップ=8サンプルなら約3300シンボルごと（約3秒ごと）で1チップ分ずれる。実用上は1000～5000シンボルごと（1～5秒ごと）に再同期すれば十分。
        - 復調結果のエラー率や信頼度（soft value）が悪化したら再探索をトリガーする
        - 連続したビットエラーやFEC復号失敗を検出したら再探索する
        - 受信信号のエネルギー低下や異常値を検出したら再探索する
        - 常にスライディングウィンドウで並行して同期点を監視し、ピークがずれたら自動補正する（計算量は増えるがリアルタイム性が高い）
      - どの戦略を採用するかは、伝送時間・計算量・リアルタイム性の要求に応じて選択する。
    - 多重ピーク対策（複数ピーク時の選択基準）
      - 理想的には「最大ピーク＝本物の同期点」だが、ノイズや周期性の影響で偽ピークが最大値になる場合がある。
      - 対策例：
        - 最大ピークと2番目ピークや平均値との比（ピーク比）が十分大きい場合のみ同期成立とみなす
        - ピーク比が閾値未満なら「同期失敗」として再探索する
        - 連続した複数回の相関計算で同じ位置にピークが現れる場合のみ同期点とする
      - 偽ピークによる誤同期を防ぐため、最大値以外の判定基準も重要。
- **FEC方式・パラメータ**（フェーズ1後半-2以降）
  - LDPC
    - 決定すべき主なパラメータ：
      - **符号長（n）**: 1ブロックあたりの総ビット数（例: 128, 256, 512, 1024など）
      - **情報ビット長（k）**: 1ブロックあたりの元データ（情報ビット）数
      - **符号化率（rate = k/n）**: 例: 1/2, 2/3, 3/4 など
      - **パリティ検査行列（H行列）の構造**: ランダム型 or 構造化型（QC-LDPC等）
      - **反復復号回数（最大反復数）**: 例: 10回, 20回, 50回など
      - **ソフト値入力のスケーリング・量子化方法**: 例: 8bit int（-128～+127）で正規化、またはfloat
    - **実装上の可変性について**
      - rateやn（符号長）は「H行列（パリティ検査行列）」の内容次第で可変可能。
      - ただし、H行列のサイズ・構造が異なる場合は、事前に複数のH行列を用意するか、動的生成ロジックが必要。
      - 一般的なLDPCライブラリでは、rateやnごとにH行列を切り替える設計が多い。
      - PoCや実験段階では「H行列を固定し、rateやnも固定」とし、必要に応じて複数パターンを切り替える方式が現実的。
      - 本格実装では「H行列の動的生成」や「rate/n可変対応」も可能だが、実装コストが上がる。
- **WebAudio関連**（フェーズ2以降）
  - サンプリングレート（AudioContext作成時にブラウザが決定する値。通常は44100Hzまたは48000Hzで固定）
  - AudioWorkletの処理単位フレーム数（バッファサイズ）：128サンプルで固定（WebAudio仕様上、process()ごとに128サンプルずつストリーム処理）
  - 必ずストリーム処理となる。128サンプル単位で逐次処理される。
- **データフレーム構造**（フェーズ2-3）
  - **新設計: 2.5バイトヘッダ方式（プリアンブル + 同期ワード + ヘッダ本体）**
    - DPSKの位相同期とフレーム同期の堅牢性を両立させるための設計。

- **評価指標**（全フェーズ）
  - BER（Bit Error Rate, ビット誤り率）: 送信ビット数に対する誤りビット数の割合。通信品質の基本指標。
  - SNR（Signal to Noise Ratio, 信号対雑音比）: 復調前後の信号パワーと雑音パワーの比（dB単位）。高いほど雑音耐性が高い。
  - 同期成功率: プリアンブルや系列同期が正しく検出できた割合。全試行数に対する同期成功回数の比率。
  - 処理遅延: 送信から復調・復元までにかかる総遅延時間（ms単位）。リアルタイム性や応答性の指標。

---

**受信処理フローの注意：**
- 新設計に基づき、受信処理は以下の階層的なステップで行う必要がある。
  1. **位相同期**: 生の信号ストリームから、まず「4ビットの`0000`プリアンブル」を検出し、DPSKの位相反転問題を解決するための基準位相を確立する。
  2. **フレーム同期**: 位相が確定したストリームから、次に「8ビットの固定同期ワード(SW)」を探索し、フレームの正確な開始点を特定する。
  3. **ヘッダ検証**: 同期ワードの直後にある「8ビットのヘッダ本体(HB)」を読み込み、パリティを検証してヘッダの正当性を確認する。
  4. **ペイロード抽出**: ヘッダが正しければ、そこに含まれるLDPC n種別情報に基づきペイロード長を確定し、該当部分を抽出する。
  5. **FEC復号**: 抽出したペイロード部分のみをFEC（LDPC）復号にかける。

---

---

- **DSSSで1対1通信・同期重視ならM系列が最もシンプルで堅牢**
- **多重化や複数ユーザー対応ならGold系列やWalsh系列が有利*
- **自己相関ピークの鋭さ・同期のしやすさはM系列＞Gold系列＞Walsh系列**

## M系列（最大長系列）生成多項式リスト（n≦7, 拡散率≦127）

| 段数n | 周期（拡散率） | 代表的な多項式（タップ位置） |
|-------|----------------|-----------------------------|
| 3     | 7              | x³ + x² + 1   （3,2）      |
| 4     | 15             | x⁴ + x³ + 1   （4,3）      |
| 5     | 31             | x⁵ + x³ + 1   （5,3）      |
| 6     | 63             | x⁶ + x⁵ + 1   （6,5）      |
| 7     | 127            | x⁷ + x⁶ + 1   （7,6）      |

- いずれもLFSRの「n段目」と「タップ位置」をXORしてフィードバックします。
- シード（初期値）は1以外の任意値（0は不可）
- 例：n=7, 多項式x⁷+x⁶+1 → LFSRの7,6ビットをXOR

---

- 拡散率31, 63, 127などが音声帯域DSSSで現実的な選択肢です。
- さらに大きなnや他の多項式が必要な場合はご相談ください。

## 拡散率・系列長・位相数について
- **拡散率＝系列長＝位相数** となります。
  - 例：拡散率31 → PN系列長31 → 位相数31（開始位置が31通り）
  - 例：拡散率127 → PN系列長127 → 位相数127
- コード同期時は「系列の全位相（開始位置）」で相関計算し、最大値の位置を系列の先頭とみなします。
- **拡散率が高いほど計算量が多くなりますが、同期精度・耐雑音性（処理利得）も高くなります。**

### 拡散率のトレードオフ
- 拡散率↑（系列長↑）
  - 長所: 雑音・干渉に強くなる（SNR改善、誤検出減少）、同期精度が上がる
  - 短所: 同期探索の計算量が増える、データレートが下がる（1ビットあたりのチップ数増加）
- 拡散率↓（系列長↓）
  - 長所: 計算量が少なく、データレートが高い
  - 短所: 雑音・干渉に弱くなり、同期誤検出も増える

## データフレーム構造（ASCIIアート）- 新設計

+------------+-----------------+----------------+-------------------------------+
| Preamble   | Sync Word (SW)  | Header Byte(HB)|   ペイロード（=データ+BCH）   |
+------------+-----------------+----------------+-------------------------------+
| 4bit       | 8bit            | 8bit           | n/8 bytes                     |
+------------+-----------------+----------------+-------------------------------+

### ヘッダ設計（プリアンブル + 同期ワード + ヘッダ本体）

#### 1. プリアンブル (Preamble) - 4ビット
- **役割**: DPSKの位相同期を確立し、後続のビットが反転しているか否かを判断する基準を提供する。
- **値**: `0000` (固定)
- **動作原理**: 4ビット連続の`0`は、DPSK変調において「4シンボル間、位相が変化しない」という非常に特徴的なパターンを生成する。受信側はまずこのパターンを検出し、基準位相を確立する。これにより、下位レイヤの相関器が位相反転を気にする必要がなくなる。

#### 2. 同期ワード (Sync Word, SW) - 8ビット
- **役割**: 位相同期が確立したストリームから、フレームの開始点を一意かつ強力に示す。旧SOHの役割を担う。
- **値**: `0b10110100` (例: 自己相関特性が良く、0/1がバランスした固定値)
- **動作原理**: 8ビットの固定パターンは、ランダムなノイズと区別しやすく、誤検出率が極めて低い（1/256）。受信機はプリアンブル検出後、この同期ワードを探索する。

#### 3. ヘッダ本体 (Header Byte, HB) - 8ビット
- **役割**: フレームのメタデータを格納し、ヘッダ自身の誤りを検出する。
- **ビット割り当て**:
    +---+---+---+---+---+---+---+---+
    | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
    +---+---+---+---+---+---+---+---+
    | S | S | S | T | T | N | N | P |
    +---+---+---+---+---+---+---+---+
      |   |   |   |   |   |   |   |
      |   |   |   |   |   |   |   +-- **ヘッダパリティ (P)**: bit7-1に対する偶数パリティ
      |   |   |   |   |   +---+------ LDPC n種別 (N): 00:128, 01:256, 10:512, 11:1024
      |   |   |   +---+-------------- 型 (T): 00:データ, 01:ACK, 10:拡張, 11:予約
      +---+---+---------------------- シーケンス番号 (S): 0-7の循環番号

- **ヘッダパリティ (P)**: ヘッダ本体の7ビット（S, T, N）に対する偶数パリティ。これにより、ヘッダが1ビットでも破損した場合、受信側でそれを検出し、フレームを破棄できる。

---

### BCH配置・FECとの関係

- **本設計では「1bit訂正可能なBCHパリティをデータ本体の末尾に付加し、ペイロード全体（データ+BCH）をFEC（LDPC）で符号化する」方式とする。**
- これは「LDPC復号後にパリティ検査を行い、失敗した場合はフレーム破棄。成功した場合のみBCH復号を行い、1bit誤りがあれば訂正する」運用とする。
- **BCHの役割は「LDPC復号でパリティOKとなったが、まれに1bitだけ誤りが残る場合の訂正」に限定される。**
- 2bit以上の誤りや、LDPCパリティNGの場合はフレーム破棄となる。
- **CRC16のような多ビット誤り検出能力は持たないが、LDPCのundetected error率が極めて低いため、BCHのみで十分実用的。**
- **BCHパリティの長さは用途・実装に応じて選択（例: BCH(15,11,1)やBCH(31,26,1)など）**

---

#### LDPC n種別ごとのBCHパリティ対応表

ヘッダ本体(HB)で指定されたLDPC n種別に基づき、ペイロードは以下のBCH符号化ルールに従います。

| LDPC n種別 | LDPC符号長n | LDPC情報長k | BCH符号         | BCH情報ビット長k | 入力バイト数 (実際制限) | BCHパリティ長 | BCH出力長 | パディング | バイト長（n/8） |
|:----------:|:-----------:|:-----------:|:----------------|:----------------|:----------------------|:-------------|:----------|:-----------|:---------------|
| 00         | 128         | 64          | BCH(63,56,1)    | 56              | 7                     | 7            | 63        | 1bit       | 16             |
| 01         | 256         | 128         | BCH(127,120,1)  | 120             | 15                    | 7            | 127       | 1bit       | 32             |
| 10         | 512         | 256         | BCH(255,247,1)  | 247             | 30                    | 8            | 255       | 1bit       | 64             |
| 11         | 1024        | 512         | BCH(511,502,1)  | 502             | 62                    | 9            | 511       | 1bit       | 128            |

- 入力バイト数は「BCH情報ビット長k / 8」の切り上げ（未使用ビットは0パディング）です。
- BCH出力（データ+BCHパリティ）は常にバイト境界（8bit単位）になるよう、余りビットは0でパディング。
- BCH復号時も同様にパディングビットを無視してデータ部のみ抽出。
- これにより、入出力は常にバイト単位・固定長となり、実装が容易。

---

## 実装決定事項（対話的解決済み）

### DPSK位相unwrapping・soft value生成
- **位相unwrapping方式**: 履歴ベース法（前回位相との連続性考慮）
- **LLR計算**: 理論式 `LLR = 4 * Es/N0 * sin(位相差)` 使用
- **Es/N0固定値**: 10dB（線形値=10.0）
- **soft value量子化**: int8_t範囲(-128～+127)にクリップ
- **実装クラス**: `PhaseUnwrapper` + `DPSKSoftDecoder`

### M系列生成
- **生成方式**: 事前生成（31要素配列）
- **多項式**: x⁵+x³+1（タップ位置5,3）
- **初期シード**: 固定値 0b10101
- **LFSR実装**: `MSequenceGenerator`クラス、周期31の完全系列

### DSSS相関計算最適化
- **PoC段階拡散率**: 15から開始（計算量約半減）
- **多項式変更**: x⁴+x³+1（タップ位置4,3）、周期15
- **段階的探索実装**: 
  1. 粗い探索: 4サンプルステップでピーク候補検出
  2. 細かい探索: ピーク候補±8サンプル範囲を1サンプルステップで精密探索
- **計算量**: 32×15 + 17×15 = 735演算/call（大幅削減）
- **実装クラス**: `TwoStageCorrelator`

### WebAudioバッファ管理
- **バッファ方式**: リングバッファ（256サンプル容量）
- **データフロー**: AudioWorklet 128サンプル/call → リングバッファ蓄積
- **相関トリガー**: バッファ蓄積60サンプル以上で相関処理開始
- **既存活用**: `utils/RingBuffer`クラス再利用（要確認・拡張）

### LDPC実装方針
- 実装**: sum-product復号アルゴリズム
- **H行列**: 固定構造（n=128, rate=1/2から開始）
- **実装言語**: TypeScript（Node.js環境）
- **soft value入力**: int8_t配列（-128～+127）
