<!DOCTYPE html>
<html lang="ja">

<head>
	<meta charset="UTF-8">
	<title>DSSS+DPSK 可視化デモ</title>
	<style>
		body {
			font-family: sans-serif;
			background: #f8f8f8;
		}

		canvas {
			background: #fff;
			border: 1px solid #ccc;
			margin-bottom: 1em;
		}

		.section {
			margin-bottom: 2em;
		}

		.histogram-bar {
			display: inline-block;
			background: #3498db;
			margin-right: 1px;
		}

		.label {
			font-size: 0.9em;
			color: #555;
		}
	</style>
</head>

<body>
	<h1>DSSS+DPSK 各段階スペクトラム・ヒストグラム可視化</h1>
	<div class="section">
		<button id="rerun">再生成</button>
		<span class="label">（ビット列・ノイズは毎回ランダム）</span>
	</div>
	<div class="section">
		<h2>0. 入力ビット列（時系列）</h2>
		<canvas id="canvas-bits" width="600" height="100"></canvas>
	</div>
	<div class="section">
		<h2>1. DSSSチップ列（時系列）</h2>
		<canvas id="canvas-chips" width="600" height="100"></canvas>
		<canvas id="canvas-chips-spectrum" width="600" height="100"></canvas>
	</div>
	<div class="section">
		<h2>2. DPSK変調信号（時系列）</h2>
		<canvas id="canvas-dpsk" width="600" height="100"></canvas>
		<canvas id="canvas-dpsk-spectrum" width="600" height="100"></canvas>
	</div>
	<div class="section">
		<h2>3. AWGN付加後の信号（時系列）</h2>
		<canvas id="canvas-noisy" width="600" height="100"></canvas>
		<canvas id="canvas-noisy-spectrum" width="600" height="100"></canvas>
	</div>
	<div class="section">
		<h2>4. ソフトバリュー（信頼度）ヒストグラム</h2>
		<div id="hist-soft"></div>
	</div>
	<div class="section">
		<h2>5. 複合ビット（復調ビット）ヒストグラム</h2>
		<div id="hist-bits"></div>
	</div>
	<div class="section">
		<h2>6. 復調ビット列（時系列）</h2>
		<canvas id="canvas-bits-demod" width="600" height="100"></canvas>
	</div>
	<div class="section">
		<h2>7. WebAudio再生・リアルタイムデコード</h2>
		<button id="play">再生</button>
		<button id="stop">停止</button>
		<span id="audio-status" class="label"></span>
		<div id="audio-decode-info" class="label"></div>
		<canvas id="canvas-bits-demod-audio" width="600" height="100"></canvas>
	</div>
	<script type="module">
		import * as modem from '../src/modems/dsss-dpsk.js';

		function randomBits(n) {
			const arr = new Int8Array(n);
			for (let i = 0; i < n; i++) arr[i] = Math.random() > 0.5 ? 1 : 0;
			return arr;
		}

		function drawSignal(canvas, arr, color = '#2c3e50', yRange = null) {
			const ctx = canvas.getContext('2d');
			ctx.clearRect(0, 0, canvas.width, canvas.height);
			const h = canvas.height, w = canvas.width;
			const N = arr.length;
			let min = yRange ? yRange[0] : Math.min(...arr);
			let max = yRange ? yRange[1] : Math.max(...arr);
			if (min === max) { min -= 1; max += 1; }
			ctx.beginPath();
			if (canvas.id.includes('bits')) {
				// 矩形波（ステップ状）で描画
				for (let i = 0; i < N; i++) {
					const x0 = i / N * w;
					const x1 = (i + 1) / N * w;
					const y = h - ((arr[i] - min) / (max - min)) * h;
					if (i === 0) ctx.moveTo(x0, y);
					else ctx.lineTo(x0, y);
					ctx.lineTo(x1, y); // 水平線
				}
			} else {
				// 通常の折れ線
				for (let i = 0; i < N; i++) {
					const x = i / (N - 1) * w;
					const y = h - ((arr[i] - min) / (max - min)) * h;
					if (i === 0) ctx.moveTo(x, y);
					else ctx.lineTo(x, y);
				}
			}
			ctx.strokeStyle = color;
			ctx.lineWidth = 1.2;
			ctx.stroke();
		}

		function fftMag(arr) {
			// Zero pad to next power of 2
			const N = 1 << Math.ceil(Math.log2(arr.length));
			const re = new Float32Array(N);
			const im = new Float32Array(N);
			for (let i = 0; i < arr.length; i++) re[i] = arr[i];
			// Simple radix-2 Cooley-Tukey FFT (real input)
			function bitrev(x, bits) {
				let y = 0;
				for (let i = 0; i < bits; i++) y = (y << 1) | ((x >> i) & 1);
				return y;
			}
			const bits = Math.log2(N);
			for (let i = 0; i < N; i++) {
				const j = bitrev(i, bits);
				if (i < j) {
					[re[i], re[j]] = [re[j], re[i]];
					[im[i], im[j]] = [im[j], im[i]];
				}
			}
			for (let s = 1; s <= bits; s++) {
				const m = 1 << s;
				const m2 = m >> 1;
				const theta = -2 * Math.PI / m;
				const wpr = Math.cos(theta);
				const wpi = Math.sin(theta);
				for (let k = 0; k < N; k += m) {
					let wr = 1, wi = 0;
					for (let j = 0; j < m2; j++) {
						const tRe = wr * re[k + j + m2] - wi * im[k + j + m2];
						const tIm = wr * im[k + j + m2] + wi * re[k + j + m2];
						re[k + j + m2] = re[k + j] - tRe;
						im[k + j + m2] = im[k + j] - tIm;
						re[k + j] += tRe;
						im[k + j] += tIm;
						const tmp = wr;
						wr = wr * wpr - wi * wpi;
						wi = wi * wpr + tmp * wpi;
					}
				}
			}
			const mag = new Float32Array(N / 2);
			for (let i = 0; i < N / 2; i++) {
				mag[i] = Math.sqrt(re[i] * re[i] + im[i] * im[i]);
			}
			return mag;
		}

		function drawSpectrum(canvas, arr) {
			const mag = fftMag(arr);
			// dBスケールに変換
			const dbArr = Array.from(mag, v => 20 * Math.log10(v + 1e-12));
			// min/max自動スケーリング
			let minDb = Math.min(...dbArr);
			let maxDb = Math.max(...dbArr);
			// 余白を少し持たせる
			const margin = 2;
			minDb -= margin;
			maxDb += margin;
			const ctx = canvas.getContext('2d');
			ctx.clearRect(0, 0, canvas.width, canvas.height);
			const h = canvas.height, w = canvas.width;
			const N = dbArr.length;
			ctx.beginPath();
			ctx.moveTo(0, h);
			for (let i = 0; i < N; i++) {
				const y = h - (dbArr[i] - minDb) / (maxDb - minDb) * h;
				ctx.lineTo(i / (N - 1) * w, y);
			}
			ctx.strokeStyle = '#e67e22';
			ctx.lineWidth = 1.5;
			ctx.stroke();
		}

		function drawHistogram(container, arr, bins = 32, range = null) {
			container.innerHTML = '';
			let min = range ? range[0] : Math.min(...arr);
			let max = range ? range[1] : Math.max(...arr);
			const hist = new Array(bins).fill(0);
			for (const v of arr) {
				let idx = Math.floor((v - min) / (max - min + 1e-9) * bins);
				if (idx < 0) idx = 0;
				if (idx >= bins) idx = bins - 1;
				hist[idx]++;
			}
			const maxCount = Math.max(...hist);
			for (let i = 0; i < bins; i++) {
				const bar = document.createElement('div');
				bar.className = 'histogram-bar';
				bar.style.height = (hist[i] / maxCount * 80 + 2) + 'px';
				bar.style.width = '10px';
				bar.title = `${min + (max - min) * i / bins}〜${min + (max - min) * (i + 1) / bins}: ${hist[i]}`;
				container.appendChild(bar);
			}
		}

		let audioCtx = null;
		let audioSource = null;
		let playing = false;
		let lastSamples = null;
		let lastParams = null;
		let lastBits = null;

		function playAudio(samples, sampleRate) {
			const buf = audioCtx.createBuffer(1, samples.length + sampleRate, sampleRate);
			buf.getChannelData(0).set(samples);
			audioSource = audioCtx.createBufferSource();
			audioSource.buffer = buf;
			audioSource.connect(audioCtx.destination);
			audioSource.start();
			playing = true;
			document.getElementById('audio-status').textContent = '再生中...';
			audioSource.onended = () => {
				playing = false;
				document.getElementById('audio-status').textContent = '停止';
			};
		}
		function stopAudio() {
			if (audioSource) audioSource.stop();
			if (audioCtx) audioCtx.close();
			playing = false;
			document.getElementById('audio-status').textContent = '停止';
		}

		function expandQueryParams() {
			const params = new URLSearchParams(window.location.search);
			const processParam = function (param, defaultValue = null) {
				if (params.has(param)) {
					const value = params.get(param);
					if (value) {
						const n = parseInt(value, 10);
						return n;
					} else {
						return defaultValue; // 空文字列はデフォルト値を返す
					}
				}
				return defaultValue;
			}

			const bitLength = processParam('bitLength', 16);
			const snr = processParam('snr', -6);

			return {
				bitLength,
				snr,
			}
		}

		function calculateParameters(params) {
			const { sampleRate, lowerBound, upperBound, sequenceLength, minCyclesPerChip = 3 } = params;

			const carrierFreq = (upperBound + lowerBound) / 2;
			const bandwidth = upperBound - lowerBound;

			if (!Number.isFinite(sampleRate) || sampleRate <= 0) throw new Error('sampleRate must be > 0');
			if (!Number.isFinite(lowerBound) || !Number.isFinite(upperBound) || lowerBound >= upperBound) throw new Error('lowerBound < upperBound required');
			if (!Number.isFinite(sequenceLength) || sequenceLength < 1) throw new Error('sequenceLength must be >= 1');
			if (bandwidth <= 0) throw new Error('bandwidth must be > 0');
			if (!Number.isFinite(minCyclesPerChip) || minCyclesPerChip < 1) throw new Error('minCyclesPerChip must be >= 1');

			// 1チップあたりminCyclesPerChip周期のキャリアを保証
			let chipRate = carrierFreq / minCyclesPerChip;
			// チップレートが帯域幅を超えないよう制限
			if (chipRate > bandwidth) chipRate = bandwidth;
			const samplesPerPhase = Math.floor(sampleRate / chipRate);

			return { sequenceLength, samplesPerPhase, sampleRate, carrierFreq, bandwidth, chipRate, minCyclesPerChip };
		}

		function run() {
			// ここで必要なパラメータを計算・取
			const { bitLength, snr } = expandQueryParams();
			console.log('bitLength:', bitLength, 'snr:', snr);

			const params = calculateParameters({
				sampleRate: 48000, // サンプルレート（任意）
				lowerBound: 100, // 下限周波数（Hz, 任意）
				upperBound: 12000, // 上限周波数（Hz, 任意）
				sequenceLength: 31, // DSSS拡散長
			});
			console.log('params:', params);
			let { sequenceLength, samplesPerPhase, sampleRate, carrierFreq, bandwidth } = params;
			
			// パラメータ
			const snrDb = snr; // AWGN SNR [dB]
			// 1. ランダムビット列
			const bits = randomBits(bitLength); // Use bitLength from query param
			bits[0] = 0;
			bits[1] = 0;
			bits[2] = 0;
			bits[3] = 0;
			lastBits = bits;
			console.log('bits:', Array.from(bits).join(''));
			// 2. DSSS拡散
			const chips = modem.dsssSpread(bits, sequenceLength);
			console.log('chips:', chips);
			// 3. DPSK変調: チップ列→位相系列（DPSK: 差動位相加算）
			const chipPhases = modem.dpskModulate(chips, 0);
			// 4. キャリア変調: 位相系列→サンプル列
			const samples = modem.modulateCarrier(chipPhases, samplesPerPhase, sampleRate, carrierFreq);
			// 5. AWGN付加
			console.log('Adding AWGN with SNR:', snrDb, 'dB');
			const noisySamples = modem.addAWGN(samples, snrDb);
			
			// 6. 同期検出: ノイズ付きサンプルから同期オフセットを検出
			const modulationParams = { samplesPerPhase, sampleRate, carrierFreq };
			const syncReference = modem.generateSyncReference(sequenceLength);
			// SNR -3dBは厳しいので、より多くの試行で同期検出
			// Use searchRangeChips from test for debugging
			const syncResult = modem.findSyncOffset(noisySamples, syncReference, modulationParams, 20, { correlationThreshold: 0.4, peakToNoiseRatio: 3.0 });
			
			console.log('Sync result:', syncResult);
			console.log('Original bits:', bits);
			console.log('Noisy samples length:', noisySamples.length);
			console.log('Expected total samples:', bitLength * sequenceLength * samplesPerPhase);
			
			const demoSyncFound = syncResult.isFound;
			
			let llr, demodBits;
			if (demoSyncFound) {
				// 7. 同期されたサンプルを取得
				const syncedSamples = modem.applySyncOffset(noisySamples, syncResult.bestSampleOffset);
				console.log('Synced samples length:', syncedSamples.length);
				console.log('Sample offset applied:', syncResult.bestSampleOffset);
				
				// 8. 完全復調チェーン: サンプル→位相→チップ→ビット
				// 8-1. キャリア復調: サンプル→位相
				const phases = modem.demodulateCarrier(syncedSamples, samplesPerPhase, sampleRate, carrierFreq);
				console.log('Phases length:', phases.length);
				
				// 8-2. DPSK復調: 位相→チップ
				const chips = modem.dpskDemodulate(phases);
				console.log('Demod chips length:', chips.length);
				
				// 8-3. DSSS逆拡散: チップ→LLR (既にLLR値を返す)
				llr = modem.dsssDespread(chips, sequenceLength);
				console.log('LLR:', llr);
				
				// 8-4. LLRからビット判定 (正のLLR = bit 0, 負のLLR = bit 1)
				demodBits = Array.from(llr).map(l => l >= 0 ? 0 : 1);
				console.log('Original bits:', bits);
				console.log('Demod bits:  ', demodBits);
				console.log('BER:', demodBits.filter((b, i) => b !== bits[i]).length / bitLength);
			} else {
				// 同期失敗時は全てニュートラルなLLRを生成
				llr = new Int8Array(bitLength).fill(0);
				demodBits = Array.from(llr).map(l => l >= 0 ? 0 : 1);
				console.log('Sync failed - using neutral LLRs');
			}

			// 入力ビット列
			drawSignal(document.getElementById('canvas-bits'), bits, '#8e44ad', [0, 1]);
			// DSSSチップ列
			drawSignal(document.getElementById('canvas-chips'), chips, '#2c3e50', [-1, 1]);
			drawSpectrum(document.getElementById('canvas-chips-spectrum'), chips);
			// サンプル単位DPSK変調信号
			drawSignal(document.getElementById('canvas-dpsk'), samples, '#16a085', [-1, 1]);
			drawSpectrum(document.getElementById('canvas-dpsk-spectrum'), samples);
			// AWGN付加後
			drawSignal(document.getElementById('canvas-noisy'), noisySamples, '#e74c3c', [-1, 1]);
			drawSpectrum(document.getElementById('canvas-noisy-spectrum'), noisySamples);
			// ソフトバリュー (LLR)
			drawHistogram(document.getElementById('hist-soft'), llr, 32, [-128, 127]);
			// 復調ビット列（時系列）
			drawSignal(document.getElementById('canvas-bits-demod'), llr.map(l => -l), '#27ae60', [-128, 127]);
			// WebAudio用に正規化（±1→±0.8）
			const audioSamples = Float32Array.from(samples, v => Math.max(-1, Math.min(1, v * 0.8)));
			lastSamples = audioSamples;
			lastParams = { samplesPerPhase, carrierFreq, sequenceLength };
			document.getElementById('audio-status').textContent = '';
			document.getElementById('audio-decode-info').textContent = '';
		}


		class TestNode extends AudioWorkletNode {
			constructor(context, opts) {
				super(context, 'test-processor', {
					numberOfInputs: 1,
					numberOfOutputs: 1,
					channelCount: 1,
					channelCountMode: "explicit",
					channelInterpretation: "discrete",
					outputChannelCount: [1],
					processorOptions: {
						...opts
					}
				});

				const llrs = [];

				this.port.onmessage = (event) => {
					if (event.data.type === 'bit') {
						const { bit, llr } = event.data;
						llrs.push(-llr);
						// 復調ビット列（時系列）
						drawSignal(document.getElementById('canvas-bits-demod-audio'), llrs, '#27ae60', [-128, 127]);
						document.getElementById('audio-decode-info').textContent = `復調ビット: ${llrs.join('')}`;
					}
				};
			}

			static async addModule(context) {
				return Promise.all([
					context.audioWorklet.addModule("./dsss-dpsk-processor.js"),
				]);
			}
		}



		document.getElementById('rerun').onclick = run;
 		document.getElementById('play').onclick = async () => {
 			if (!lastBits || !lastParams) return;
 			if (audioCtx) audioCtx.close();
 			audioCtx = new window.AudioContext();
 			await TestNode.addModule(audioCtx);
 			const sampleRate = audioCtx.sampleRate;
 
 			// ここで必要なパラメータを計算・取
 			const { bitLength, snr } = expandQueryParams();
 			const params = calculateParameters({
 				sampleRate,
 				lowerBound: 100, // 下限周波数（Hz, 任意）
 				upperBound: 12000, // 上限周波数（Hz, 任意）
 				sequenceLength: 31 // DSSS拡散長
 			});
 			const { sequenceLength, samplesPerPhase, carrierFreq, bandwidth } = params;
 
 			const testNode = new TestNode(audioCtx, {
				seed: null,
 				sequenceLength,
 				samplesPerPhase,
 				carrierFreq,
 				bandwidth,
 			});
 
 			const stream = await navigator.mediaDevices.getUserMedia({
 			audio: {
 				sampleRate,
 				channelCount: 1,
 				echoCancellation: false,
 				noiseSuppression: false,
 				autoGainControl: false
 			}
 			});
 			const source = audioCtx.createMediaStreamSource(stream);
 			source.connect(testNode);
 			testNode.connect(audioCtx.destination);
			window.stream = stream;
			window.source = source;
 
 			await new Promise(resolve => setTimeout(resolve, 200));
 
 			// 信号をWebAudioサンプルレートで再生成
 			const chips = modem.dsssSpread(lastBits, sequenceLength);
 			const chipPhases = modem.dpskModulate(chips, 0);
 			const samples = modem.modulateCarrier(chipPhases, samplesPerPhase, sampleRate, carrierFreq);
 			const audioSamples = Float32Array.from(samples, v => v * 0.8);
 			lastSamples = audioSamples;

			if (true) {
				playAudio(audioSamples, sampleRate);
			} else { 
				const buf = audioCtx.createBuffer(1, audioSamples.length + sampleRate, sampleRate);
				buf.getChannelData(0).set(audioSamples);
				audioSource = audioCtx.createBufferSource();
				audioSource.buffer = buf;
				audioSource.connect(testNode);
				audioSource.start();
			}
 		};
 		document.getElementById('stop').onclick = stopAudio;
		run();
	</script>
</body>

</html>
